{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "table",
  "type": "registry:ui",
  "title": "Table",
  "description": "A terminal table component for displaying tabular data",
  "files": [
    {
      "path": "ui/table.tsx",
      "type": "registry:ui",
      "target": "components/ui/table.tsx",
      "content": "/**\n * Table component for ink-web\n */\n\nimport React from 'react'\nimport { Box, Text } from 'ink-web/bundled'\n\ntype Scalar = string | number | boolean | null | undefined\n\ntype ScalarDict = {\n  [key: string]: Scalar\n}\n\nexport type CellProps = React.PropsWithChildren<{ column: number }>\n\nexport type TableProps<T extends ScalarDict> = {\n  data: T[]\n  columns?: (keyof T)[]\n  padding?: number\n  header?: (props: React.PropsWithChildren<{}>) => React.ReactElement\n  cell?: (props: CellProps) => React.ReactElement\n  skeleton?: (props: React.PropsWithChildren<{}>) => React.ReactElement\n}\n\nfunction Header(props: React.PropsWithChildren<{}>) {\n  return (\n    <Text bold color=\"blue\">\n      {props.children}\n    </Text>\n  )\n}\n\nfunction Cell(props: CellProps) {\n  return <Text>{props.children}</Text>\n}\n\nfunction Skeleton(props: React.PropsWithChildren<{}>) {\n  return <Text bold>{props.children}</Text>\n}\n\ntype ColumnInfo<T> = {\n  key: string\n  field: keyof T\n  width: number\n}\n\nexport function Table<T extends ScalarDict>({\n  data,\n  columns: columnsProp,\n  padding = 1,\n  header = Header,\n  cell = Cell,\n  skeleton = Skeleton,\n}: TableProps<T>) {\n  // Determine which columns to display\n  const getColumns = (): (keyof T)[] => {\n    if (columnsProp) return columnsProp\n\n    const keys = new Set<keyof T>()\n    for (const row of data) {\n      for (const key in row) {\n        keys.add(key)\n      }\n    }\n    return Array.from(keys)\n  }\n\n  const columns = getColumns()\n\n  // Calculate column widths\n  const calculateColumnWidths = (): ColumnInfo<T>[] => {\n    return columns.map((field) => {\n      const headerWidth = String(field).length\n      const maxDataWidth = Math.max(\n        ...data.map((row) => {\n          const value = row[field]\n          return value == null ? 0 : String(value).length\n        }),\n        0\n      )\n      return {\n        field,\n        key: String(field),\n        width: Math.max(headerWidth, maxDataWidth) + padding * 2,\n      }\n    })\n  }\n\n  const columnInfo = calculateColumnWidths()\n\n  // Render a single row with configurable borders and cell renderer\n  const renderRow = (\n    rowData: Partial<T>,\n    borders: { left: string; right: string; cross: string; fill: string },\n    CellComponent: React.FC<any>\n  ) => {\n    const cells: React.ReactNode[] = []\n\n    columnInfo.forEach((col, index) => {\n      const value = rowData[col.field]\n      const content = value == null ? borders.fill.repeat(col.width) : formatCell(value, col.width, borders.fill)\n\n      cells.push(\n        <CellComponent key={`${col.key}-${index}`} column={index}>\n          {content}\n        </CellComponent>\n      )\n\n      // Add separator between columns\n      if (index < columnInfo.length - 1) {\n        cells.push(<Skeleton key={`sep-${index}`}>{borders.cross}</Skeleton>)\n      }\n    })\n\n    return (\n      <Box flexDirection=\"row\">\n        <Skeleton>{borders.left}</Skeleton>\n        {cells}\n        <Skeleton>{borders.right}</Skeleton>\n      </Box>\n    )\n  }\n\n  // Format cell content with padding\n  const formatCell = (value: Scalar, width: number, fill: string): string => {\n    const str = String(value)\n    const leftPad = padding\n    const rightPad = width - str.length - padding\n    return `${fill.repeat(leftPad)}${str}${fill.repeat(rightPad)}`\n  }\n\n  // Create header data\n  const headerData = columns.reduce(\n    (acc, col) => ({ ...acc, [col]: col }),\n    {} as Partial<T>\n  )\n\n  return (\n    <Box flexDirection=\"column\">\n      {/* Top border */}\n      {renderRow({}, { left: '┌', right: '┐', cross: '┬', fill: '─' }, skeleton)}\n\n      {/* Header row */}\n      {renderRow(headerData, { left: '│', right: '│', cross: '│', fill: ' ' }, header)}\n\n      {/* Data rows with separators */}\n      {data.map((row, index) => (\n        <Box flexDirection=\"column\" key={`row-${index}`}>\n          {renderRow({}, { left: '├', right: '┤', cross: '┼', fill: '─' }, skeleton)}\n          {renderRow(row, { left: '│', right: '│', cross: '│', fill: ' ' }, cell)}\n        </Box>\n      ))}\n\n      {/* Bottom border */}\n      {renderRow({}, { left: '└', right: '┘', cross: '┴', fill: '─' }, skeleton)}\n    </Box>\n  )\n}\n\nexport default Table\nexport { Header, Cell, Skeleton }\n"
    }
  ]
}
