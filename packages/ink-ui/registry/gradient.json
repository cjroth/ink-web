{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gradient",
  "type": "registry:ui",
  "title": "Gradient",
  "description": "A gradient color component for terminal-style interfaces with built-in presets and custom colors",
  "files": [
    {
      "path": "ui/gradient.tsx",
      "type": "registry:ui",
      "target": "components/ui/gradient.tsx",
      "content": "import type { ReactNode } from 'react'\nimport { Transform } from 'ink-web/bundled'\n\nexport type GradientName =\n  | 'cristal'\n  | 'teen'\n  | 'mind'\n  | 'morning'\n  | 'vice'\n  | 'passion'\n  | 'fruit'\n  | 'instagram'\n  | 'atlas'\n  | 'retro'\n  | 'summer'\n  | 'pastel'\n  | 'rainbow'\n\nexport interface GradientProps {\n  children: ReactNode\n  /**\n   * The name of a built-in gradient.\n   * Mutually exclusive with `colors`.\n   */\n  name?: GradientName\n  /**\n   * Array of hex color strings to create a custom gradient.\n   * Mutually exclusive with `name`.\n   */\n  colors?: string[]\n}\n\ninterface RGB {\n  r: number\n  g: number\n  b: number\n}\n\n// Built-in gradient presets\nconst GRADIENTS: Record<GradientName, string[]> = {\n  cristal: ['#bdfff3', '#4ac29a'],\n  teen: ['#77a1d3', '#79cbca', '#e684ae'],\n  mind: ['#473b7b', '#3584a7', '#30d2be'],\n  morning: ['#ff5f6d', '#ffc371'],\n  vice: ['#5ee7df', '#b490ca'],\n  passion: ['#f43b47', '#453a94'],\n  fruit: ['#ff4e50', '#f9d423'],\n  instagram: ['#833ab4', '#fd1d1d', '#fcb045'],\n  atlas: ['#feac5e', '#c779d0', '#4bc0c8'],\n  retro: ['#3f51b1', '#5a55ae', '#7b5fac', '#8f6aae', '#a86aa4', '#cc6b8e', '#f18271', '#f3a469', '#f7c978'],\n  summer: ['#fdbb2d', '#22c1c3'],\n  rainbow: ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ff0000'],\n  pastel: ['#74ebd5', '#ACB6E5'],\n}\n\n/**\n * Parse a hex color string to RGB values\n */\nfunction hexToRgb(hex: string): RGB {\n  const normalized = hex.replace('#', '')\n  const r = parseInt(normalized.substring(0, 2), 16)\n  const g = parseInt(normalized.substring(2, 4), 16)\n  const b = parseInt(normalized.substring(4, 6), 16)\n  return { r, g, b }\n}\n\n/**\n * Convert RGB values to ANSI 24-bit color escape code\n */\nfunction rgbToAnsi(rgb: RGB): string {\n  return `\\x1b[38;2;${rgb.r};${rgb.g};${rgb.b}m`\n}\n\n/**\n * Linear interpolation between two values\n */\nfunction lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t\n}\n\n/**\n * Interpolate between two RGB colors\n */\nfunction interpolateColor(color1: RGB, color2: RGB, t: number): RGB {\n  return {\n    r: Math.round(lerp(color1.r, color2.r, t)),\n    g: Math.round(lerp(color1.g, color2.g, t)),\n    b: Math.round(lerp(color1.b, color2.b, t)),\n  }\n}\n\n/**\n * Strip ANSI escape codes from a string\n */\nfunction stripAnsi(str: string): string {\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/\\x1b\\[[0-9;]*m/g, '')\n}\n\n/**\n * Generate an array of interpolated colors for a gradient\n */\nfunction generateGradient(colors: string[], steps: number): RGB[] {\n  if (colors.length === 0) {\n    throw new Error('At least one color is required')\n  }\n\n  if (colors.length === 1) {\n    const singleColor = hexToRgb(colors[0])\n    return Array(steps).fill(singleColor)\n  }\n\n  const rgbColors = colors.map(hexToRgb)\n  const result: RGB[] = []\n  const segmentLength = steps / (rgbColors.length - 1)\n\n  for (let i = 0; i < steps; i++) {\n    const segmentIndex = Math.min(Math.floor(i / segmentLength), rgbColors.length - 2)\n    const segmentProgress = (i % segmentLength) / segmentLength\n    const color = interpolateColor(rgbColors[segmentIndex], rgbColors[segmentIndex + 1], segmentProgress)\n    result.push(color)\n  }\n\n  return result\n}\n\n/**\n * Apply gradient to text (multiline mode - gradient applies horizontally per line)\n */\nfunction applyGradient(text: string, colors: string[]): string {\n  const cleanText = stripAnsi(text)\n  const lines = cleanText.split('\\n')\n  const maxLength = Math.max(...lines.map((line) => line.length))\n\n  if (maxLength === 0) {\n    return text\n  }\n\n  const gradientColors = generateGradient(colors, maxLength)\n  const result: string[] = []\n\n  for (const line of lines) {\n    let coloredLine = ''\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i]\n      const color = gradientColors[i]\n      coloredLine += rgbToAnsi(color) + char\n    }\n    // Reset color at end of line\n    if (line.length > 0) {\n      coloredLine += '\\x1b[0m'\n    }\n    result.push(coloredLine)\n  }\n\n  return result.join('\\n')\n}\n\n/**\n * Gradient component for Ink\n *\n * Apply beautiful color gradients to terminal text. Supports both built-in\n * gradient presets and custom color arrays.\n *\n * @example\n * ```tsx\n * // Using a built-in gradient\n * <Gradient name=\"rainbow\">\n *   <Text>Hello World!</Text>\n * </Gradient>\n *\n * // Using custom colors\n * <Gradient colors={['#ff0000', '#00ff00', '#0000ff']}>\n *   <Text>Custom Gradient</Text>\n * </Gradient>\n * ```\n */\nexport const Gradient = ({ children, name, colors }: GradientProps) => {\n  if (name && colors) {\n    throw new Error('The `name` and `colors` props are mutually exclusive')\n  }\n\n  if (!name && !colors) {\n    throw new Error('Either `name` or `colors` prop must be provided')\n  }\n\n  const gradientColors = name ? GRADIENTS[name] : colors!\n\n  return (\n    <Transform transform={(text: string) => applyGradient(text, gradientColors)}>\n      {children}\n    </Transform>\n  )\n}\n\nexport default Gradient\n"
    }
  ]
}
