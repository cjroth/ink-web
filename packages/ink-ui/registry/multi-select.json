{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "multi-select",
  "type": "registry:ui",
  "title": "Multi Select",
  "description": "A terminal multi-select input with keyboard navigation",
  "files": [
    {
      "path": "ui/multi-select.tsx",
      "type": "registry:ui",
      "target": "components/ui/multi-select.tsx",
      "content": "/**\n * Multi Select component for ink-web\n *\n * Based on ink-multi-select by George Karagkiaouris\n * https://github.com/karaggeorge/ink-multi-select\n * MIT License\n *\n * Adapted for browser compatibility with ink-web by removing Node.js dependencies.\n */\n\nimport React, { useState, useEffect, useRef, useCallback } from 'react'\nimport { Box, Text, useInput } from 'ink-web/bundled'\n\nexport type MultiSelectItem<V> = {\n  key?: string\n  label: string\n  value: V\n}\n\nexport interface IndicatorProps {\n  readonly isHighlighted?: boolean\n}\n\nexport interface CheckboxProps {\n  readonly isSelected?: boolean\n}\n\nexport interface ItemProps {\n  readonly isHighlighted?: boolean\n  readonly label: string\n}\n\nfunction DefaultIndicator({ isHighlighted = false }: IndicatorProps) {\n  return (\n    <Box marginRight={1}>\n      <Text color={isHighlighted ? 'blue' : undefined}>\n        {isHighlighted ? '❯' : ' '}\n      </Text>\n    </Box>\n  )\n}\n\nfunction DefaultCheckbox({ isSelected = false }: CheckboxProps) {\n  return (\n    <Box marginRight={1}>\n      <Text color=\"green\">\n        {isSelected ? '◉' : '◯'}\n      </Text>\n    </Box>\n  )\n}\n\nfunction DefaultItem({ isHighlighted = false, label }: ItemProps) {\n  return <Text color={isHighlighted ? 'blue' : undefined}>{label}</Text>\n}\n\n// Simple array rotation helper\nfunction rotateArray<T>(array: T[], count: number): T[] {\n  const len = array.length\n  if (len === 0) return array\n  const normalizedCount = ((count % len) + len) % len\n  return [...array.slice(normalizedCount), ...array.slice(0, normalizedCount)]\n}\n\n// Deep equality check for arrays of items\nfunction areItemsEqual<V>(a: MultiSelectItem<V>[], b: MultiSelectItem<V>[]): boolean {\n  if (a.length !== b.length) return false\n  return a.every((item, index) => {\n    const other = b[index]\n    return item.value === other?.value && item.label === other?.label\n  })\n}\n\nexport interface MultiSelectProps<V> {\n  items?: MultiSelectItem<V>[]\n  selected?: MultiSelectItem<V>[]\n  defaultSelected?: MultiSelectItem<V>[]\n  focus?: boolean\n  initialIndex?: number\n  limit?: number\n  indicatorComponent?: React.FC<IndicatorProps>\n  checkboxComponent?: React.FC<CheckboxProps>\n  itemComponent?: React.FC<ItemProps>\n  onSelect?: (item: MultiSelectItem<V>) => void\n  onUnselect?: (item: MultiSelectItem<V>) => void\n  onSubmit?: (items: MultiSelectItem<V>[]) => void\n  onHighlight?: (item: MultiSelectItem<V>) => void\n}\n\nexport function MultiSelect<V>({\n  items = [],\n  selected: controlledSelected,\n  defaultSelected = [],\n  focus = true,\n  initialIndex = 0,\n  limit: customLimit,\n  indicatorComponent: IndicatorComponent = DefaultIndicator,\n  checkboxComponent: CheckboxComponent = DefaultCheckbox,\n  itemComponent: ItemComponent = DefaultItem,\n  onSelect,\n  onUnselect,\n  onSubmit,\n  onHighlight,\n}: MultiSelectProps<V>) {\n  const hasLimit = typeof customLimit === 'number' && items.length > customLimit\n  const limit = hasLimit ? Math.min(customLimit, items.length) : items.length\n\n  const [rotateIndex, setRotateIndex] = useState(0)\n  const [highlightedIndex, setHighlightedIndex] = useState(\n    initialIndex > limit - 1 ? limit - 1 : initialIndex\n  )\n  const [internalSelected, setInternalSelected] = useState<MultiSelectItem<V>[]>(defaultSelected)\n  const previousItems = useRef<MultiSelectItem<V>[]>(items)\n\n  const selected = controlledSelected ?? internalSelected\n\n  const isSelected = useCallback((value: V) => {\n    return selected.some(item => item.value === value)\n  }, [selected])\n\n  useEffect(() => {\n    if (!areItemsEqual(previousItems.current, items)) {\n      setRotateIndex(0)\n      setHighlightedIndex(0)\n    }\n    previousItems.current = items\n  }, [items])\n\n  useInput(\n    useCallback(\n      (input, key) => {\n        if (input === 'k' || key.upArrow) {\n          const lastIdx = limit - 1\n          const atFirstIndex = highlightedIndex === 0\n          const nextIndex = hasLimit ? highlightedIndex : lastIdx\n          const nextRotateIndex = atFirstIndex ? rotateIndex + 1 : rotateIndex\n          const nextHighlightedIndex = atFirstIndex ? nextIndex : highlightedIndex - 1\n\n          setRotateIndex(nextRotateIndex)\n          setHighlightedIndex(nextHighlightedIndex)\n\n          const slicedItems = hasLimit\n            ? rotateArray(items, nextRotateIndex).slice(0, limit)\n            : items\n\n          if (typeof onHighlight === 'function' && slicedItems[nextHighlightedIndex]) {\n            onHighlight(slicedItems[nextHighlightedIndex])\n          }\n        }\n\n        if (input === 'j' || key.downArrow) {\n          const atLastIndex = highlightedIndex === limit - 1\n          const nextIndex = hasLimit ? highlightedIndex : 0\n          const nextRotateIndex = atLastIndex ? rotateIndex - 1 : rotateIndex\n          const nextHighlightedIndex = atLastIndex ? nextIndex : highlightedIndex + 1\n\n          setRotateIndex(nextRotateIndex)\n          setHighlightedIndex(nextHighlightedIndex)\n\n          const slicedItems = hasLimit\n            ? rotateArray(items, nextRotateIndex).slice(0, limit)\n            : items\n\n          if (typeof onHighlight === 'function' && slicedItems[nextHighlightedIndex]) {\n            onHighlight(slicedItems[nextHighlightedIndex])\n          }\n        }\n\n        if (input === ' ') {\n          const slicedItems = hasLimit\n            ? rotateArray(items, rotateIndex).slice(0, limit)\n            : items\n          const item = slicedItems[highlightedIndex]\n\n          if (item) {\n            if (isSelected(item.value)) {\n              onUnselect?.(item)\n              const newSelected = selected.filter(s => s.value !== item.value)\n              if (!controlledSelected) {\n                setInternalSelected(newSelected)\n              }\n            } else {\n              onSelect?.(item)\n              const newSelected = [...selected, item]\n              if (!controlledSelected) {\n                setInternalSelected(newSelected)\n              }\n            }\n          }\n        }\n\n        if (key.return) {\n          onSubmit?.(selected)\n        }\n      },\n      [hasLimit, limit, rotateIndex, highlightedIndex, items, selected, controlledSelected, isSelected, onSelect, onUnselect, onSubmit, onHighlight]\n    ),\n    { isActive: focus }\n  )\n\n  const slicedItems = hasLimit\n    ? rotateArray(items, rotateIndex).slice(0, limit)\n    : items\n\n  return (\n    <Box flexDirection=\"column\">\n      {slicedItems.map((item, index) => {\n        const isHighlighted = index === highlightedIndex\n        const itemIsSelected = isSelected(item.value)\n        return (\n          <Box key={item.key ?? String(item.value)}>\n            <IndicatorComponent isHighlighted={isHighlighted} />\n            <CheckboxComponent isSelected={itemIsSelected} />\n            <ItemComponent {...item} isHighlighted={isHighlighted} />\n          </Box>\n        )\n      })}\n    </Box>\n  )\n}\n\nexport default MultiSelect\n"
    }
  ]
}
