{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "multi-select",
  "type": "registry:ui",
  "title": "Multi Select",
  "description": "A multi-select input component with keyboard navigation",
  "files": [
    {
      "path": "ui/multi-select.tsx",
      "type": "registry:ui",
      "target": "components/ui/multi-select.tsx",
      "content": "/**\n * Multi Select component for ink-web\n */\n\nimport React, { useState, useCallback } from 'react'\nimport { Box, Text, useInput } from 'ink-web/bundled'\n\nexport type MultiSelectItem<V> = {\n  key?: string\n  label: string\n  value: V\n}\n\nexport interface IndicatorProps {\n  readonly isHighlighted?: boolean\n}\n\nexport interface CheckboxProps {\n  readonly isSelected?: boolean\n}\n\nexport interface ItemProps {\n  readonly isHighlighted?: boolean\n  readonly label: string\n}\n\nfunction DefaultIndicator({ isHighlighted = false }: IndicatorProps) {\n  return (\n    <Box marginRight={1}>\n      <Text color={isHighlighted ? 'blue' : undefined}>\n        {isHighlighted ? '❯' : ' '}\n      </Text>\n    </Box>\n  )\n}\n\nfunction DefaultCheckbox({ isSelected = false }: CheckboxProps) {\n  return (\n    <Box marginRight={1}>\n      <Text color=\"green\">\n        {isSelected ? '◉' : '◯'}\n      </Text>\n    </Box>\n  )\n}\n\nfunction DefaultItem({ isHighlighted = false, label }: ItemProps) {\n  return <Text color={isHighlighted ? 'blue' : undefined}>{label}</Text>\n}\n\nexport interface MultiSelectProps<V> {\n  items?: MultiSelectItem<V>[]\n  selected?: MultiSelectItem<V>[]\n  defaultSelected?: MultiSelectItem<V>[]\n  focus?: boolean\n  initialIndex?: number\n  limit?: number\n  indicatorComponent?: React.FC<IndicatorProps>\n  checkboxComponent?: React.FC<CheckboxProps>\n  itemComponent?: React.FC<ItemProps>\n  onSelect?: (item: MultiSelectItem<V>) => void\n  onUnselect?: (item: MultiSelectItem<V>) => void\n  onSubmit?: (items: MultiSelectItem<V>[]) => void\n  onHighlight?: (item: MultiSelectItem<V>) => void\n}\n\nexport function MultiSelect<V>({\n  items = [],\n  selected: controlledSelected,\n  defaultSelected = [],\n  focus = true,\n  initialIndex = 0,\n  limit,\n  indicatorComponent: IndicatorComponent = DefaultIndicator,\n  checkboxComponent: CheckboxComponent = DefaultCheckbox,\n  itemComponent: ItemComponent = DefaultItem,\n  onSelect,\n  onUnselect,\n  onSubmit,\n  onHighlight,\n}: MultiSelectProps<V>) {\n  // Calculate visible range\n  const visibleCount = limit && limit < items.length ? limit : items.length\n  const clampedInitial = Math.min(initialIndex, items.length - 1)\n\n  const [highlightedIndex, setHighlightedIndex] = useState(Math.max(0, clampedInitial))\n  const [scrollOffset, setScrollOffset] = useState(\n    limit ? Math.max(0, clampedInitial - Math.floor(limit / 2)) : 0\n  )\n  const [internalSelected, setInternalSelected] = useState<MultiSelectItem<V>[]>(defaultSelected)\n\n  const selected = controlledSelected ?? internalSelected\n\n  const isSelected = useCallback(\n    (value: V) => {\n      return selected.some(item => item.value === value)\n    },\n    [selected]\n  )\n\n  // Get visible items based on scroll offset\n  const visibleItems = limit\n    ? items.slice(scrollOffset, scrollOffset + visibleCount)\n    : items\n\n  // Calculate the index within visible items\n  const visibleHighlightedIndex = highlightedIndex - scrollOffset\n\n  useInput(\n    useCallback(\n      (input, key) => {\n        if (input === 'k' || key.upArrow) {\n          const newIndex = highlightedIndex > 0 ? highlightedIndex - 1 : items.length - 1\n          setHighlightedIndex(newIndex)\n\n          // Update scroll offset if needed\n          if (limit && newIndex < scrollOffset) {\n            setScrollOffset(newIndex)\n          } else if (limit && newIndex >= items.length - 1 && scrollOffset + visibleCount < items.length) {\n            setScrollOffset(Math.max(0, items.length - visibleCount))\n          }\n\n          onHighlight?.(items[newIndex]!)\n        }\n\n        if (input === 'j' || key.downArrow) {\n          const newIndex = highlightedIndex < items.length - 1 ? highlightedIndex + 1 : 0\n          setHighlightedIndex(newIndex)\n\n          // Update scroll offset if needed\n          if (limit && newIndex >= scrollOffset + visibleCount) {\n            setScrollOffset(newIndex - visibleCount + 1)\n          } else if (limit && newIndex === 0) {\n            setScrollOffset(0)\n          }\n\n          onHighlight?.(items[newIndex]!)\n        }\n\n        if (input === ' ') {\n          const item = items[highlightedIndex]\n          if (!item) return\n\n          if (isSelected(item.value)) {\n            onUnselect?.(item)\n            const newSelected = selected.filter(s => s.value !== item.value)\n            if (!controlledSelected) {\n              setInternalSelected(newSelected)\n            }\n          } else {\n            onSelect?.(item)\n            const newSelected = [...selected, item]\n            if (!controlledSelected) {\n              setInternalSelected(newSelected)\n            }\n          }\n        }\n\n        if (key.return) {\n          onSubmit?.(selected)\n        }\n      },\n      [\n        highlightedIndex,\n        scrollOffset,\n        items,\n        limit,\n        visibleCount,\n        selected,\n        controlledSelected,\n        isSelected,\n        onSelect,\n        onUnselect,\n        onSubmit,\n        onHighlight,\n      ]\n    ),\n    { isActive: focus }\n  )\n\n  return (\n    <Box flexDirection=\"column\">\n      {visibleItems.map((item, index) => {\n        const actualIndex = scrollOffset + index\n        const isHighlighted = index === visibleHighlightedIndex\n        const itemIsSelected = isSelected(item.value)\n        return (\n          <Box key={item.key ?? String(item.value)}>\n            <IndicatorComponent isHighlighted={isHighlighted} />\n            <CheckboxComponent isSelected={itemIsSelected} />\n            <ItemComponent {...item} isHighlighted={isHighlighted} />\n          </Box>\n        )\n      })}\n    </Box>\n  )\n}\n\nexport default MultiSelect\n"
    }
  ]
}
